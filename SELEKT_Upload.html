<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SELEKT ‚Äî ÂÜôÁúü„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Syne:wght@400;500;600;700;800&family=Zen+Kaku+Gothic+New:wght@400;500;700&family=Space+Mono:wght@400;700&display=swap"
        rel="stylesheet">

    <!-- face-api.js for face detection -->
    <script defer src="https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js"></script>
    <!-- exifr for EXIF data (shooting time) -->
    <script src="https://cdn.jsdelivr.net/npm/exifr@7.1.3/dist/full.umd.js"></script>

    <style>
        :root {
            --bg: #0E1015;
            --surface: #161920;
            --surface2: #1C2028;
            --surface3: #242830;
            --border: #2C3038;
            --border2: #383D48;
            --text: #E0E2E8;
            --text-sub: #8890A0;
            --text-dim: #505868;
            --coral: #C87080;
            --green: #5AAA90;
            --lavender: #8878B8;
            --gold: #C0A050;
            --blue: #6090B8;
            --radius: 14px;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Syne', 'Zen Kaku Gothic New', sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* ===== TOP BAR ===== */
        .topbar {
            height: 56px;
            background: var(--surface);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            padding: 0 24px;
            gap: 16px;
            flex-shrink: 0;
        }

        .logo {
            font-size: 18px;
            font-weight: 800;
            color: #fff;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        .logo span {
            color: rgba(255, 255, 255, 0.5);
        }

        .topbar-divider {
            width: 1px;
            height: 24px;
            background: var(--border);
        }

        .topbar-title {
            font-size: 14px;
            color: var(--text-sub);
            font-weight: 500;
        }

        /* ===== STEP INDICATOR ===== */
        .steps {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0;
            padding: 24px 24px 0;
        }

        .step {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .step-num {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: var(--surface2);
            border: 2px solid var(--border2);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 13px;
            font-weight: 700;
            color: var(--text-dim);
            transition: all 0.3s;
            flex-shrink: 0;
        }

        .step.active .step-num {
            background: var(--coral);
            border-color: var(--coral);
            color: white;
        }

        .step.done .step-num {
            background: var(--green);
            border-color: var(--green);
            color: white;
        }

        .step-label {
            font-size: 12px;
            font-weight: 600;
            color: var(--text-dim);
            white-space: nowrap;
        }

        .step.active .step-label {
            color: var(--text);
        }

        .step.done .step-label {
            color: var(--green);
        }

        .step-line {
            width: 48px;
            height: 2px;
            background: var(--border2);
            margin: 0 4px;
            flex-shrink: 0;
        }

        .step-line.done {
            background: var(--green);
        }

        /* ===== MAIN CONTENT ===== */
        .main {
            flex: 1;
            padding: 24px;
            max-width: 900px;
            margin: 0 auto;
            width: 100%;
        }

        /* ===== STEP PANELS ===== */
        .step-panel {
            display: none;
        }

        .step-panel.active {
            display: block;
        }

        /* ===== UPLOAD ZONE ===== */
        .upload-zone {
            border: 2px dashed var(--border2);
            border-radius: 20px;
            padding: 60px 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.25s;
            background: var(--surface);
            position: relative;
        }

        .upload-zone:hover,
        .upload-zone.drag-over {
            border-color: var(--coral);
            background: rgba(255, 107, 107, 0.05);
        }

        .upload-zone input[type="file"] {
            position: absolute;
            inset: 0;
            opacity: 0;
            cursor: pointer;
            width: 100%;
            height: 100%;
        }

        .upload-icon {
            font-size: 56px;
            margin-bottom: 16px;
        }

        .upload-title {
            font-size: 20px;
            font-weight: 700;
            margin-bottom: 8px;
        }

        .upload-sub {
            font-size: 13px;
            color: var(--text-sub);
            line-height: 1.6;
        }

        .upload-btn {
            display: inline-block;
            margin-top: 20px;
            padding: 12px 28px;
            background: var(--coral);
            color: white;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 700;
            cursor: pointer;
            border: none;
            font-family: 'Syne', 'Zen Kaku Gothic New', sans-serif;
            transition: opacity 0.2s;
        }

        .upload-btn:hover {
            opacity: 0.85;
        }

        /* ===== PREVIEW GRID ===== */
        .preview-section {
            margin-top: 28px;
            display: none;
        }

        .preview-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 14px;
        }

        .preview-count {
            font-size: 14px;
            font-weight: 700;
            color: var(--text);
        }

        .preview-count span {
            color: var(--coral);
        }

        .preview-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(90px, 1fr));
            gap: 8px;
        }

        .preview-thumb {
            aspect-ratio: 3/4;
            border-radius: 8px;
            overflow: hidden;
            background: var(--surface2);
            position: relative;
        }

        .preview-thumb img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .preview-thumb .thumb-name {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0, 0, 0, 0.7);
            font-size: 8px;
            color: rgba(255, 255, 255, 0.7);
            padding: 3px 4px;
            font-family: 'Space Mono', monospace;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .preview-thumb .thumb-remove {
            position: absolute;
            top: 4px;
            right: 4px;
            width: 18px;
            height: 18px;
            background: rgba(255, 107, 107, 0.9);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: white;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.15s;
            border: none;
        }

        .preview-thumb:hover .thumb-remove {
            opacity: 1;
        }

        /* ===== NEXT BUTTON ===== */
        .action-bar {
            margin-top: 28px;
            display: flex;
            justify-content: flex-end;
            gap: 12px;
        }

        .btn-primary {
            padding: 14px 32px;
            background: var(--coral);
            color: white;
            border-radius: 12px;
            font-size: 15px;
            font-weight: 700;
            cursor: pointer;
            border: none;
            font-family: 'Syne', 'Zen Kaku Gothic New', sans-serif;
            transition: opacity 0.2s, transform 0.15s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary:hover {
            opacity: 0.88;
            transform: translateY(-1px);
        }

        .btn-primary:disabled {
            opacity: 0.4;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            padding: 14px 24px;
            background: var(--surface2);
            color: var(--text-sub);
            border-radius: 12px;
            font-size: 15px;
            font-weight: 600;
            cursor: pointer;
            border: 1px solid var(--border2);
            font-family: 'Syne', 'Zen Kaku Gothic New', sans-serif;
            transition: background 0.2s;
        }

        .btn-secondary:hover {
            background: var(--surface3);
        }

        /* ===== AI PROCESSING ===== */
        .ai-processing {
            text-align: center;
            padding: 60px 20px;
        }

        .ai-spinner {
            width: 64px;
            height: 64px;
            border: 4px solid var(--surface3);
            border-top-color: var(--coral);
            border-radius: 50%;
            animation: spin 0.9s linear infinite;
            margin: 0 auto 24px;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        .ai-title {
            font-size: 20px;
            font-weight: 700;
            margin-bottom: 8px;
        }

        .ai-sub {
            font-size: 13px;
            color: var(--text-sub);
            margin-bottom: 24px;
        }

        .ai-progress-bar {
            width: 280px;
            height: 6px;
            background: var(--surface3);
            border-radius: 4px;
            margin: 0 auto;
            overflow: hidden;
        }

        .ai-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--coral), var(--lavender));
            border-radius: 4px;
            width: 0%;
            transition: width 0.4s ease;
        }

        .ai-log {
            margin-top: 20px;
            font-size: 12px;
            color: var(--text-dim);
            font-family: 'Space Mono', monospace;
            min-height: 20px;
        }

        /* ===== GROUP CONFIRM ===== */
        .group-confirm-header {
            margin-bottom: 20px;
        }

        .group-confirm-title {
            font-size: 20px;
            font-weight: 700;
            margin-bottom: 6px;
        }

        .group-confirm-sub {
            font-size: 13px;
            color: var(--text-sub);
        }

        .group-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .group-card {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            overflow: hidden;
            transition: border-color 0.2s;
        }

        .group-card:hover {
            border-color: var(--border2);
        }

        .group-card-header {
            display: flex;
            align-items: center;
            gap: 14px;
            padding: 14px 16px;
            cursor: pointer;
            user-select: none;
        }

        .group-label-badge {
            width: 32px;
            height: 32px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: 800;
            color: white;
            flex-shrink: 0;
        }

        .group-name-wrap {
            flex: 1;
        }

        .group-name-input {
            background: transparent;
            border: none;
            font-size: 15px;
            font-weight: 700;
            color: var(--text);
            font-family: inherit;
            width: 100%;
            outline: none;
            cursor: text;
            padding: 2px 6px;
            border-radius: 6px;
            transition: background 0.15s;
        }

        .group-name-input:focus {
            background: var(--surface2);
        }

        .group-name-placeholder {
            font-size: 12px;
            color: var(--text-dim);
            margin-top: 2px;
            padding-left: 6px;
        }

        .group-meta {
            display: flex;
            align-items: center;
            gap: 12px;
            flex-shrink: 0;
        }

        .group-photo-count {
            font-size: 12px;
            color: var(--text-sub);
            background: var(--surface2);
            padding: 4px 10px;
            border-radius: 20px;
        }

        .group-limit-wrap {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .group-limit-label {
            font-size: 11px;
            color: var(--text-dim);
        }

        .group-limit-input {
            width: 48px;
            background: var(--surface2);
            border: 1px solid var(--border2);
            border-radius: 8px;
            color: var(--text);
            font-size: 13px;
            font-weight: 700;
            text-align: center;
            padding: 5px 4px;
            font-family: 'Space Mono', monospace;
            outline: none;
        }

        .group-limit-input:focus {
            border-color: var(--coral);
        }

        .group-limit-unit {
            font-size: 11px;
            color: var(--text-dim);
        }

        .group-toggle {
            font-size: 18px;
            color: var(--text-dim);
            transition: transform 0.2s;
        }

        .group-card.open .group-toggle {
            transform: rotate(180deg);
        }

        .group-card-photos {
            display: none;
            padding: 0 16px 16px;
        }

        .group-card.open .group-card-photos {
            display: block;
        }

        .group-photos-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(72px, 1fr));
            gap: 6px;
        }

        .group-photo-thumb {
            aspect-ratio: 3/4;
            border-radius: 6px;
            overflow: hidden;
            background: var(--surface2);
            position: relative;
        }

        .group-photo-thumb img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .group-photo-thumb .ai-badge-mini {
            position: absolute;
            top: 3px;
            left: 3px;
            background: rgba(255, 107, 107, 0.9);
            color: white;
            font-size: 8px;
            font-weight: 700;
            padding: 1px 4px;
            border-radius: 4px;
        }

        .group-reason {
            font-size: 11px;
            color: var(--text-dim);
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .group-reason-icon {
            font-size: 14px;
        }

        /* Drag & Drop styles */
        .group-photo-thumb[draggable="true"] {
            cursor: grab;
            transition: opacity 0.2s, transform 0.15s, box-shadow 0.2s;
        }

        .group-photo-thumb[draggable="true"]:hover {
            box-shadow: 0 0 0 2px var(--coral);
            transform: scale(1.05);
        }

        .group-photo-thumb.dragging {
            opacity: 0.3;
            transform: scale(0.9);
        }

        .group-photos-grid.drag-over {
            background: rgba(255, 107, 107, 0.1);
            border: 2px dashed var(--coral);
            border-radius: 8px;
            min-height: 60px;
        }

        .btn-add-group {
            width: 100%;
            padding: 16px;
            background: var(--surface);
            border: 2px dashed var(--border);
            border-radius: var(--radius);
            color: var(--text-sub);
            font-size: 14px;
            font-weight: 600;
            font-family: inherit;
            cursor: pointer;
            transition: all 0.2s;
            margin-top: 8px;
        }

        .btn-add-group:hover {
            border-color: var(--coral);
            color: var(--coral);
            background: rgba(255, 107, 107, 0.05);
        }

        .btn-delete-group {
            background: none;
            border: none;
            color: var(--text-dim);
            font-size: 18px;
            cursor: pointer;
            padding: 4px 8px;
            border-radius: 6px;
            transition: all 0.15s;
        }

        .btn-delete-group:hover {
            color: var(--coral);
            background: rgba(255, 107, 107, 0.1);
        }

        .group-photo-thumb.selected {
            box-shadow: 0 0 0 3px #5AAA90;
            transform: scale(0.95);
        }

        .group-photo-thumb.selected::after {
            content: '‚úì';
            position: absolute;
            top: 4px;
            right: 4px;
            width: 20px;
            height: 20px;
            background: #5AAA90;
            color: white;
            font-size: 12px;
            font-weight: 700;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .selection-bar {
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 8px;
            padding: 10px 16px;
            background: rgba(20, 25, 35, 0.92);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid #5AAA90;
            border-radius: 10px;
            margin-bottom: 12px;
            font-size: 13px;
            font-weight: 600;
            color: #5AAA90;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .selection-bar .sel-label {
            margin-right: 4px;
        }

        .selection-bar .sel-arrow {
            color: var(--text-dim);
            font-size: 12px;
        }

        .selection-bar button {
            background: none;
            border: 1px solid #5AAA90;
            color: #5AAA90;
            padding: 4px 12px;
            border-radius: 6px;
            font-size: 12px;
            font-family: inherit;
            cursor: pointer;
            transition: all 0.15s;
        }

        .selection-bar button:hover {
            background: #5AAA90;
            color: white;
        }

        .selection-bar .dest-btn {
            padding: 5px 14px;
            border-radius: 20px;
            font-weight: 700;
            color: white;
            border: none;
            font-size: 12px;
        }

        .selection-bar .dest-btn:hover {
            opacity: 0.8;
            transform: scale(1.05);
        }

        .btn-undo {
            background: var(--surface2);
            border: 1px solid var(--border);
            color: var(--text-sub);
            padding: 6px 14px;
            border-radius: 8px;
            font-size: 12px;
            font-weight: 600;
            font-family: inherit;
            cursor: pointer;
            transition: all 0.15s;
        }

        .btn-undo:hover {
            background: var(--surface3);
            color: var(--text);
        }

        .btn-undo:disabled {
            opacity: 0.3;
            cursor: default;
        }

        .summary-bar {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            padding: 14px 20px;
            display: flex;
            align-items: center;
            gap: 24px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .summary-item {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .summary-val {
            font-size: 20px;
            font-weight: 800;
            color: var(--coral);
        }

        .summary-key {
            font-size: 11px;
            color: var(--text-dim);
        }

        /* ===== SHARE MODAL ===== */
        .share-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 500;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.25s;
            backdrop-filter: blur(4px);
        }

        .share-overlay.open {
            opacity: 1;
            pointer-events: all;
        }

        .share-modal {
            background: var(--surface);
            border: 1px solid var(--border2);
            border-radius: 20px;
            padding: 36px;
            max-width: 440px;
            width: 90%;
            text-align: center;
        }

        .share-icon {
            font-size: 48px;
            margin-bottom: 16px;
        }

        .share-title {
            font-size: 20px;
            font-weight: 800;
            margin-bottom: 8px;
        }

        .share-sub {
            font-size: 13px;
            color: var(--text-sub);
            margin-bottom: 24px;
            line-height: 1.6;
        }

        .share-link-box {
            background: var(--surface2);
            border: 1px solid var(--border2);
            border-radius: 10px;
            padding: 12px 16px;
            font-family: 'Space Mono', monospace;
            font-size: 12px;
            color: var(--text-sub);
            margin-bottom: 16px;
            word-break: break-all;
            text-align: left;
        }

        .share-copy-btn {
            width: 100%;
            padding: 14px;
            background: var(--coral);
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 700;
            cursor: pointer;
            font-family: 'Syne', 'Zen Kaku Gothic New', sans-serif;
            margin-bottom: 10px;
            transition: opacity 0.2s;
        }

        .share-copy-btn:hover {
            opacity: 0.85;
        }

        .share-preview-btn {
            width: 100%;
            padding: 12px;
            background: var(--surface3);
            color: var(--text);
            border: none;
            border-radius: 10px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            font-family: 'Syne', 'Zen Kaku Gothic New', sans-serif;
            transition: background 0.2s;
        }

        .share-preview-btn:hover {
            background: var(--border2);
        }

        /* ===== TOAST ===== */
        .toast {
            position: fixed;
            bottom: 24px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--surface3);
            border: 1px solid var(--border2);
            color: var(--text);
            padding: 10px 20px;
            border-radius: 10px;
            font-size: 13px;
            font-weight: 600;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.25s;
            pointer-events: none;
            white-space: nowrap;
        }

        .toast.show {
            opacity: 1;
        }

        /* ===== MOBILE ===== */
        @media (max-width: 600px) {
            body {
                overflow-x: hidden;
            }

            .main {
                padding: 16px 12px 100px;
            }

            .topbar {
                padding: 0 12px;
                gap: 8px;
            }

            .topbar-title {
                font-size: 12px;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            }

            .logo {
                font-size: 16px;
                flex-shrink: 0;
            }

            .steps {
                padding: 0 8px;
                gap: 0;
            }

            .step-label {
                font-size: 10px;
                white-space: nowrap;
            }

            .step-num {
                width: 24px;
                height: 24px;
                font-size: 12px;
            }

            .upload-zone {
                padding: 30px 16px;
            }

            .upload-title {
                font-size: 16px;
            }

            .upload-sub {
                font-size: 12px;
                word-break: break-all;
                overflow-wrap: break-word;
            }

            .upload-btn {
                font-size: 13px;
                padding: 10px 16px;
                white-space: nowrap;
            }

            .group-meta {
                flex-wrap: wrap;
                gap: 8px;
            }

            .summary-bar {
                gap: 12px;
                flex-wrap: wrap;
            }

            /* Prevent text overflow globally */
            h1,
            h2,
            h3,
            h4,
            p,
            span,
            label,
            button {
                overflow-wrap: break-word;
                word-wrap: break-word;
            }

            button {
                white-space: nowrap;
            }

            /* Group cards spacing */
            .group-card {
                padding: 16px;
            }

            .group-card input[type="text"],
            .group-card input[type="number"],
            .group-card select {
                font-size: 16px;
                /* prevents iOS zoom on focus */
            }
        }
    </style>
</head>

<body>

    <!-- TOP BAR -->
    <div class="topbar">
        <div class="logo">SE<span>LEKT</span></div>
        <div class="topbar-divider"></div>
        <div class="topbar-title">ÂÜôÁúü„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ &amp; „Ç∞„É´„Éº„ÉóË®≠ÂÆö</div>
    </div>

    <!-- STEP INDICATOR -->
    <div class="steps">
        <div class="step active" id="stepInd1">
            <div class="step-num">1</div>
            <div class="step-label">ÂÜôÁúü„ÇíÈÅ∏„Å∂</div>
        </div>
        <div class="step-line" id="stepLine1"></div>
        <div class="step" id="stepInd2">
            <div class="step-num">2</div>
            <div class="step-label">„Ç∞„É´„Éº„ÉóË®≠ÂÆö</div>
        </div>
        <div class="step-line" id="stepLine2"></div>
        <div class="step" id="stepInd3">
            <div class="step-num">3</div>
            <div class="step-label">Á¢∫Ë™ç &amp; ÂÖ±Êúâ</div>
        </div>
    </div>

    <!-- MAIN -->
    <div class="main">

        <!-- ===== STEP 1: UPLOAD ===== -->
        <div class="step-panel active" id="panel1">
            <div class="upload-zone" id="uploadZone">
                <input type="file" id="fileInput" accept="image/jpeg,image/png,image/heic,image/heif" multiple>
                <input type="file" id="folderInput" accept="image/jpeg,image/png,image/heic,image/heif" webkitdirectory
                    multiple style="display:none;">
                <div class="upload-icon"><svg width="56" height="56" viewBox="0 0 56 56" fill="none"
                        xmlns="http://www.w3.org/2000/svg">
                        <rect x="4" y="12" width="48" height="36" rx="6" stroke="rgba(255,255,255,0.3)"
                            stroke-width="2" />
                        <circle cx="28" cy="30" r="10" stroke="rgba(255,255,255,0.5)" stroke-width="2" />
                        <circle cx="28" cy="30" r="5" fill="rgba(255,255,255,0.15)" />
                        <rect x="38" y="16" width="8" height="4" rx="1" fill="rgba(255,255,255,0.2)" />
                        <path d="M24 8h8l3 4H21l3-4z" fill="rgba(255,255,255,0.2)" />
                    </svg></div>
                <div class="upload-title">ÂÜôÁúü„Çí„Éâ„É©„ÉÉ„Ç∞ÔºÜ„Éâ„É≠„ÉÉ„Éó</div>
                <div class="upload-sub">
                    „Åæ„Åü„ÅØ‰∏ã„ÅÆ„Éú„Çø„É≥„Åã„ÇâÈÅ∏Êäû<br>
                    JPG / PNG ÂØæÂøú „Éª Ë§áÊï∞„Éï„Ç°„Ç§„É´‰∏ÄÊã¨OK
                </div>
                <div style="display:flex;gap:10px;justify-content:center;flex-wrap:wrap;">
                    <button class="upload-btn"
                        onclick="document.getElementById('fileInput').click(); event.stopPropagation();">
                        üñºÔ∏è „Éï„Ç°„Ç§„É´„ÇíÈÅ∏Êäû
                    </button>
                    <button class="upload-btn" style="background:rgba(255,255,255,0.08);"
                        onclick="document.getElementById('folderInput').click(); event.stopPropagation();">
                        üìÅ „Éï„Ç©„É´„ÉÄ„ÇíÈÅ∏Êäû
                    </button>
                </div>
            </div>

            <div class="preview-section" id="previewSection">
                <div class="preview-header">
                    <div class="preview-count"><span id="photoCount">0</span> Êûö„ÅÆÂÜôÁúü„ÇíÈÅ∏Êäû‰∏≠</div>
                    <button class="btn-secondary" style="padding:8px 16px;font-size:13px"
                        onclick="clearAll()">„Åô„Åπ„Å¶ÂâäÈô§</button>
                </div>
                <div class="preview-grid" id="previewGrid"></div>
            </div>

            <div class="action-bar" style="display:flex;gap:12px;flex-wrap:wrap">
                <button class="btn-primary" id="skipGroupBtn" disabled onclick="skipGrouping()">
                    Ê¨°„Å∏ÈÄ≤„ÇÄ ‚Üí
                </button>
                <button class="btn-secondary" id="step1Next" disabled onclick="startAI()"
                    style="padding:14px 24px;font-size:13px;font-weight:600;border-radius:12px;cursor:pointer">
                    ‚ú¶ AI„ÅßÁ∞°Êòì„Ç∞„É´„Éº„ÉóÂàÜ„Åë
                </button>
            </div>
        </div>

        <!-- ===== STEP 2: AI PROCESSING ===== -->
        <div class="step-panel" id="panel2">
            <div class="ai-processing">
                <div class="ai-spinner"></div>
                <div class="ai-title">AI„Åå„Ç∞„É´„Éº„ÉóÂåñ‰∏≠...</div>
                <div class="ai-sub">ÂÜôÁúü„ÅÆÊßãÂõ≥„ÉªÊíÆÂΩ±ÊôÇÂàª„ÉªËâ≤„ÇíËß£Êûê„Åó„Å¶„ÅÑ„Åæ„Åô</div>
                <div class="ai-progress-bar">
                    <div class="ai-progress-fill" id="aiProgressFill"></div>
                </div>
                <div class="ai-log" id="aiLog">„É¢„Éá„É´„ÇíË™≠„ÅøËæº„Åø‰∏≠...</div>
            </div>
        </div>

        <!-- ===== STEP 3: GROUP CONFIRM ===== -->
        <div class="step-panel" id="panel3">
            <div class="group-confirm-header">
                <div class="group-confirm-title">„Ç∞„É´„Éº„Éó„ÇíÁ¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ</div>
                <div class="group-confirm-sub">ÂÜôÁúü„Çí„Éâ„É©„ÉÉ„Ç∞&„Éâ„É≠„ÉÉ„Éó„Åß„Ç∞„É´„Éº„ÉóÈñì„ÇíÁßªÂãï„Åß„Åç„Åæ„Åô</div>
            </div>

            <div class="summary-bar" id="summaryBar">
                <div class="summary-item">
                    <div class="summary-val" id="sumPhotos">0</div>
                    <div class="summary-key">Êûö„ÅÆÂÜôÁúü</div>
                </div>
                <div class="summary-item">
                    <div class="summary-val" id="sumGroups">0</div>
                    <div class="summary-key">„Ç∞„É´„Éº„Éó</div>
                </div>
                <div class="summary-item">
                    <div class="summary-val" id="sumLimit">0</div>
                    <div class="summary-key">ÂêàË®àÈÅ∏Êäû‰∏äÈôê</div>
                </div>
            </div>

            <div class="group-list" id="groupList"></div>
            <button class="btn-add-group" onclick="addNewGroup()">Ôºã Êñ∞„Åó„ÅÑ„Ç∞„É´„Éº„Éó„ÇíËøΩÂä†</button>

            <div
                style="margin:20px 0;padding:16px;background:var(--surface);border:1px solid var(--border);border-radius:12px;">
                <div style="font-size:13px;font-weight:700;margin-bottom:12px;color:var(--text);">üìã
                    „Çª„ÉÉ„Ç∑„Éß„É≥ÊÉÖÂ†±Ôºà„Çª„É¨„ÇØ„ÉàÁîªÈù¢„Å´Ë°®Á§∫„Åï„Çå„Åæ„ÅôÔºâ</div>
                <div style="display:flex;flex-direction:column;gap:10px;">
                    <input type="text" id="sessionTitle" placeholder="„Éó„É≠„Ç∏„Çß„ÇØ„ÉàÂêçÔºà‰ªªÊÑèÔºâ" maxlength="50"
                        style="width:100%;padding:10px 14px;background:var(--bg);border:1px solid var(--border);border-radius:8px;color:var(--text);font-size:14px;font-family:inherit;box-sizing:border-box;">
                    <input type="text" id="photographerName" placeholder="„Ç´„É°„É©„Éû„É≥ÂêçÔºà‰ªªÊÑèÔºâ" maxlength="30"
                        style="width:100%;padding:10px 14px;background:var(--bg);border:1px solid var(--border);border-radius:8px;color:var(--text);font-size:14px;font-family:inherit;box-sizing:border-box;">
                </div>
            </div>

            <div class="action-bar">
                <button class="btn-secondary" onclick="goToStep(1)">‚Üê „ÇÑ„ÇäÁõ¥„Åô</button>
                <button class="btn-undo" id="undoBtn" disabled onclick="undo()">‚Ü© ÂÖÉ„Å´Êàª„Åô</button>
                <button class="btn-primary" id="previewBtn" onclick="previewSelect()">
                    ÂÖ±Êúâ„É™„É≥„ÇØ„ÇíÁô∫Ë°å & „Çª„É¨„ÇØ„Éà ‚Üí
                </button>
            </div>
        </div>

    </div><!-- /main -->

    <!-- TOAST -->
    <div class="toast" id="toast"></div>

    <script>
        // ===== STATE =====
        let uploadedFiles = [];   // { file, url, exif, faceData }
        let groups = [];          // { label, name, reason, color, limit, photos[] }
        let faceApiReady = false;

        const GROUP_COLORS = [
            '#C87080', '#5AAA90', '#8878B8', '#6090B8', '#C0A050',
            '#C08060', '#C07060', '#6090B8', '#5098A0', '#80A858'
        ];
        const LABELS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';

        // ===== IndexedDB for Original Photos =====
        const DB_NAME = 'SelektDB';
        const STORE_NAME = 'originalPhotos';

        function openDB() {
            return new Promise((resolve, reject) => {
                const req = indexedDB.open(DB_NAME, 1);
                req.onupgradeneeded = () => req.result.createObjectStore(STORE_NAME);
                req.onsuccess = () => resolve(req.result);
                req.onerror = () => reject(req.error);
            });
        }

        async function saveOriginalFile(photoId, file) {
            const db = await openDB();
            return new Promise((resolve, reject) => {
                const tx = db.transaction(STORE_NAME, 'readwrite');
                tx.objectStore(STORE_NAME).put(file, photoId);
                tx.oncomplete = () => resolve();
                tx.onerror = () => reject(tx.error);
            });
        }

        async function getOriginalFile(photoId) {
            const db = await openDB();
            return new Promise((resolve) => {
                const req = db.transaction(STORE_NAME).objectStore(STORE_NAME).get(photoId);
                req.onsuccess = () => resolve(req.result || null);
                req.onerror = () => resolve(null);
            });
        }

        // ===== DRAG & DROP =====
        const zone = document.getElementById('uploadZone');
        zone.addEventListener('dragover', e => { e.preventDefault(); zone.classList.add('drag-over'); });
        zone.addEventListener('dragleave', () => zone.classList.remove('drag-over'));
        zone.addEventListener('drop', e => {
            e.preventDefault();
            zone.classList.remove('drag-over');
            handleFiles([...e.dataTransfer.files]);
        });
        document.getElementById('fileInput').addEventListener('change', e => {
            handleFiles([...e.target.files]);
            e.target.value = '';
        });
        document.getElementById('folderInput').addEventListener('change', e => {
            handleFiles([...e.target.files]);
            e.target.value = '';
        });

        function handleFiles(files) {
            const imgs = files.filter(f => f.type.startsWith('image/'));
            imgs.forEach(f => {
                if (uploadedFiles.find(u => u.file.name === f.name && u.file.size === f.size)) return;
                const url = URL.createObjectURL(f);
                // Store subfolder path for auto-grouping
                const relPath = f.webkitRelativePath || '';
                const subfolder = relPath ? relPath.split('/').slice(0, -1).pop() || '' : '';
                uploadedFiles.push({ file: f, url, exif: null, faceData: null, subfolder });
                const photoId = f.name;
                saveOriginalFile(photoId, f).catch(e => console.warn('IndexedDB save failed:', e));
            });
            renderPreviews();
        }

        function renderPreviews() {
            const grid = document.getElementById('previewGrid');
            const section = document.getElementById('previewSection');
            const btn = document.getElementById('step1Next');
            const skipBtn = document.getElementById('skipGroupBtn');
            document.getElementById('photoCount').textContent = uploadedFiles.length;

            if (uploadedFiles.length === 0) {
                section.style.display = 'none';
                btn.disabled = true;
                if (skipBtn) skipBtn.disabled = true;
                return;
            }
            section.style.display = 'block';
            btn.disabled = false;
            if (skipBtn) skipBtn.disabled = false;

            grid.innerHTML = '';
            uploadedFiles.forEach((item, i) => {
                const div = document.createElement('div');
                div.className = 'preview-thumb';
                div.innerHTML = `
          <img src="${item.url}" alt="${item.file.name}" loading="lazy">
          <div class="thumb-name">${item.file.name}</div>
          <button class="thumb-remove" onclick="removeFile(${i})">‚úï</button>
        `;
                grid.appendChild(div);
            });
        }

        function removeFile(i) {
            URL.revokeObjectURL(uploadedFiles[i].url);
            uploadedFiles.splice(i, 1);
            renderPreviews();
        }

        function clearAll() {
            uploadedFiles.forEach(u => URL.revokeObjectURL(u.url));
            uploadedFiles = [];
            renderPreviews();
        }

        // ===== STEP NAVIGATION =====
        function goToStep(n) {
            document.querySelectorAll('.step-panel').forEach((p, i) => {
                p.classList.toggle('active', i + 1 === n);
            });
            // Update step indicators
            for (let i = 1; i <= 3; i++) {
                const ind = document.getElementById(`stepInd${i}`);
                ind.classList.remove('active', 'done');
                if (i < n) ind.classList.add('done');
                else if (i === n) ind.classList.add('active');
            }
            for (let i = 1; i <= 2; i++) {
                const line = document.getElementById(`stepLine${i}`);
                line.classList.toggle('done', i < n);
            }
        }

        // ===== AI GROUPING =====
        async function startAI() {
            goToStep(2);
            setProgress(0, 'EXIF„Éá„Éº„Çø„ÇíË™≠„ÅøÂèñ„Çä‰∏≠...');

            // Step A: Read EXIF
            await readAllExif();
            setProgress(15, 'È°îÊ§úÂá∫„É¢„Éá„É´„ÇíÊ∫ñÂÇô‰∏≠...');

            // Step B: Load face-api models (face detection + landmarks + recognition)
            await loadFaceApi();
            // Progress 25-40 is set inside loadFaceApi/detectAllFaces

            // Step C: Detect faces + extract descriptors
            await detectAllFaces();
            setProgress(70, 'Ëâ≤„ÇíËß£Êûê‰∏≠...');

            // Step D: Color analysis
            await analyzeColors();
            setProgress(85, '‰∫∫Áâ©„ÉªÊßãÂõ≥„Åß„Ç∞„É´„Éº„ÉóÂåñ‰∏≠...');

            // Step E: Group by person √ó shot type
            await new Promise(r => setTimeout(r, 300));
            groups = buildGroups();
            setProgress(100, `${groups.length}„Ç∞„É´„Éº„Éó„Å´ÂàÜÈ°ûÂÆå‰∫ÜÔºÅ`);

            await new Promise(r => setTimeout(r, 600));
            renderGroupConfirm();
            goToStep(3);
        }

        // ===== SKIP GROUPING (single group) =====
        function skipGrouping() {
            // Check if files have subfolder info for auto-grouping
            const subfolders = new Set(uploadedFiles.map(f => f.subfolder).filter(Boolean));
            if (subfolders.size > 1) {
                // Auto-group by subfolder
                const labels = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
                let i = 0;
                groups = [];
                subfolders.forEach(folder => {
                    const label = labels[i % labels.length];
                    const photos = uploadedFiles.filter(f => f.subfolder === folder);
                    groups.push({
                        label,
                        name: folder,
                        reason: '',
                        color: GROUP_COLORS[i % GROUP_COLORS.length],
                        limit: photos.length,
                        photos
                    });
                    i++;
                });
            } else {
                groups = [{
                    label: 'A',
                    name: 'A',
                    reason: '',
                    color: GROUP_COLORS[0],
                    limit: uploadedFiles.length,
                    photos: [...uploadedFiles]
                }];
            }
            renderGroupConfirm();
            goToStep(3);
        }

        function setProgress(pct, msg) {
            document.getElementById('aiProgressFill').style.width = pct + '%';
            document.getElementById('aiLog').textContent = msg;
        }

        // --- EXIF ---
        async function readAllExif() {
            for (const item of uploadedFiles) {
                try {
                    const exif = await exifr.parse(item.file, { pick: ['DateTimeOriginal', 'CreateDate'] });
                    item.exif = exif;
                } catch { item.exif = null; }
            }
            // Sort by shooting time if available
            uploadedFiles.sort((a, b) => {
                const ta = a.exif?.DateTimeOriginal || a.exif?.CreateDate || new Date(0);
                const tb = b.exif?.DateTimeOriginal || b.exif?.CreateDate || new Date(0);
                return new Date(ta) - new Date(tb);
            });
        }

        // --- FACE API ---
        async function loadFaceApi() {
            if (faceApiReady) return;
            try {
                const MODEL_URL = 'https://cdn.jsdelivr.net/npm/@vladmandic/face-api@1.7.13/model';
                setProgress(25, 'È°îË™çË≠ò„É¢„Éá„É´„ÇíË™≠„ÅøËæº„Åø‰∏≠...');
                await Promise.all([
                    faceapi.nets.ssdMobilenetv1.loadFromUri(MODEL_URL),
                    faceapi.nets.faceLandmark68Net.loadFromUri(MODEL_URL),
                    faceapi.nets.faceRecognitionNet.loadFromUri(MODEL_URL),
                ]);
                faceApiReady = true;
                console.log('[FaceAPI] Models loaded: ssdMobilenetv1 + faceLandmark68Net + faceRecognitionNet');
            } catch (e) {
                console.warn('face-api load failed, skipping face detection:', e);
            }
        }

        async function detectAllFaces() {
            const opts = new faceapi.SsdMobilenetv1Options({ minConfidence: 0.3 });
            for (let i = 0; i < uploadedFiles.length; i++) {
                const item = uploadedFiles[i];
                setProgress(40 + Math.round(25 * i / uploadedFiles.length), `È°î„ÇíÊ§úÂá∫‰∏≠... ${i + 1}/${uploadedFiles.length}`);
                try {
                    if (!faceApiReady) { item.faceData = null; continue; }
                    const img = await loadImage(item.url);
                    const origArea = img.width * img.height;

                    // Resize for speed (max 640px)
                    const canvas = document.createElement('canvas');
                    const scale = Math.min(1, 640 / Math.max(img.width, img.height));
                    canvas.width = Math.round(img.width * scale);
                    canvas.height = Math.round(img.height * scale);
                    canvas.getContext('2d').drawImage(img, 0, 0, canvas.width, canvas.height);

                    // Detect with landmarks + descriptor
                    const detections = await faceapi
                        .detectAllFaces(canvas, opts)
                        .withFaceLandmarks()
                        .withFaceDescriptors();

                    if (detections.length > 0) {
                        // Pick the largest face
                        let maxIdx = 0, maxArea = 0;
                        detections.forEach((d, idx) => {
                            const area = d.detection.box.width * d.detection.box.height;
                            if (area > maxArea) { maxArea = area; maxIdx = idx; }
                        });
                        // Scale face area back to original image size
                        const faceRatio = (maxArea / (canvas.width * canvas.height));
                        item.faceData = {
                            count: detections.length,
                            maxFaceRatio: faceRatio,
                            descriptor: detections[maxIdx].descriptor
                        };
                        console.log(`[Face] ${item.file.name}: ${detections.length} faces, ratio=${(faceRatio * 100).toFixed(1)}%`);
                    } else {
                        item.faceData = { count: 0, maxFaceRatio: 0, descriptor: null };
                        console.log(`[Face] ${item.file.name}: no faces detected`);
                    }
                } catch (e) {
                    console.warn('Face detection failed for', item.file.name, e);
                    item.faceData = null;
                }
            }
        }

        function loadImage(url) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                img.onload = () => resolve(img);
                img.onerror = reject;
                img.src = url;
            });
        }

        // --- COLOR ANALYSIS ---
        async function analyzeColors() {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 32; canvas.height = 32;

            for (const item of uploadedFiles) {
                try {
                    const img = await loadImage(item.url);
                    ctx.drawImage(img, 0, 0, 32, 32);
                    const data = ctx.getImageData(0, 0, 32, 32).data;
                    let r = 0, g = 0, b = 0;
                    for (let i = 0; i < data.length; i += 4) {
                        r += data[i]; g += data[i + 1]; b += data[i + 2];
                    }
                    const px = 32 * 32;
                    item.avgColor = { r: r / px, g: g / px, b: b / px };
                } catch { item.avgColor = null; }
            }
        }

        function colorDist(c1, c2) {
            if (!c1 || !c2) return 0;
            return Math.sqrt(
                Math.pow(c1.r - c2.r, 2) +
                Math.pow(c1.g - c2.g, 2) +
                Math.pow(c1.b - c2.b, 2)
            );
        }

        // --- FACE DESCRIPTOR DISTANCE ---
        function descriptorDist(d1, d2) {
            if (!d1 || !d2) return Infinity;
            let sum = 0;
            for (let i = 0; i < d1.length; i++) {
                sum += (d1[i] - d2[i]) * (d1[i] - d2[i]);
            }
            return Math.sqrt(sum);
        }

        // --- SHOT TYPE CLASSIFICATION ---
        function classifyShotType(faceRatio) {
            if (faceRatio > 0.03) return 'ÂØÑ„Çä';  // Face > 3% of image ‚Üí close-up / bust
            return 'ÂÖ®Ë∫´';                         // < 3% ‚Üí full body / wide
        }

        // --- PERSON CLUSTERING ---
        function clusterByPerson(photos) {
            const THRESHOLD = 0.6;
            const clusters = [];

            for (const p of photos) {
                const desc = p.faceData?.descriptor;
                if (!desc) {
                    let nofaceCluster = clusters.find(c => c.personId === -1);
                    if (!nofaceCluster) {
                        nofaceCluster = { personId: -1, centroid: null, descriptors: [], photos: [] };
                        clusters.push(nofaceCluster);
                    }
                    nofaceCluster.photos.push(p);
                    continue;
                }

                // Find closest cluster
                let bestIdx = -1, bestDist = Infinity;
                clusters.forEach((c, idx) => {
                    if (c.personId === -1) return;
                    const dist = descriptorDist(desc, c.centroid);
                    if (dist < bestDist) { bestDist = dist; bestIdx = idx; }
                });

                if (bestIdx >= 0 && bestDist < THRESHOLD) {
                    clusters[bestIdx].photos.push(p);
                    clusters[bestIdx].descriptors.push(desc);
                    // Update centroid as running average
                    const descs = clusters[bestIdx].descriptors;
                    const avg = new Float32Array(128);
                    for (const d of descs) {
                        for (let i = 0; i < 128; i++) avg[i] += d[i];
                    }
                    for (let i = 0; i < 128; i++) avg[i] /= descs.length;
                    clusters[bestIdx].centroid = avg;
                    console.log(`[Cluster] ${p.file.name} ‚Üí person ${clusters[bestIdx].personId} (dist=${bestDist.toFixed(3)})`);
                } else {
                    const pid = clusters.filter(c => c.personId >= 0).length;
                    clusters.push({
                        personId: pid,
                        centroid: desc,
                        descriptors: [desc],
                        photos: [p]
                    });
                    console.log(`[Cluster] ${p.file.name} ‚Üí NEW person ${pid} (nearest dist=${bestDist === Infinity ? 'none' : bestDist.toFixed(3)})`);
                }
            }

            console.log(`[Cluster] Total: ${clusters.length} clusters, ${clusters.filter(c => c.personId >= 0).length} persons`);
            return clusters;
        }

        // --- BUILD GROUPS (person √ó shot type) ---
        function buildGroups() {
            if (uploadedFiles.length === 0) return [];

            // Step 1: Cluster by person
            const personClusters = clusterByPerson(uploadedFiles);
            console.log('[Grouping]', personClusters.length, 'person clusters');

            // Step 2: Subdivide each person cluster by shot type
            const result = [];
            personClusters.forEach((cluster) => {
                const byType = {};
                cluster.photos.forEach(p => {
                    const ratio = p.faceData?.maxFaceRatio || 0;
                    const type = classifyShotType(ratio);
                    if (!byType[type]) byType[type] = [];
                    byType[type].push(p);
                });

                // Create a group for each (person, shotType) combo
                const personLabel = cluster.personId === -1 ? '„Åù„ÅÆ‰ªñ' : `‰∫∫Áâ©${cluster.personId + 1}`;
                for (const [shotType, photos] of Object.entries(byType)) {
                    result.push({
                        photos,
                        personLabel,
                        shotType,
                        personId: cluster.personId
                    });
                }
            });

            // Sort: by personId then shot type
            result.sort((a, b) => {
                if (a.personId !== b.personId) return a.personId - b.personId;
                const order = { 'ÂÖ®Ë∫´': 0, '„Éê„Çπ„Éà„Ç¢„ÉÉ„Éó': 1, 'ÂØÑ„Çä': 2 };
                return (order[a.shotType] || 0) - (order[b.shotType] || 0);
            });

            // Assign labels, names, colors
            return result.map((g, i) => {
                const label = LABELS[i] || String(i + 1);
                const color = GROUP_COLORS[i % GROUP_COLORS.length];
                const name = label;
                const defaultLimit = g.photos.length;
                return { label, name, reason: '', color, limit: defaultLimit, photos: g.photos };
            });
        }

        // --- RENDER STEP 3 ---
        let _dragData = null;
        let _selectedPhotos = new Set();
        let _lastClicked = null;
        let _groupHistory = []; // For undo (1 step)

        function _selKey(gi, pi) { return `${gi}-${pi}`; }

        function saveState() {
            _groupHistory = [JSON.parse(JSON.stringify(
                groups.map(g => ({
                    label: g.label, name: g.name, reason: g.reason,
                    color: g.color, limit: g.limit,
                    // Save photo references by index in uploadedFiles
                    photoIndices: g.photos.map(p => uploadedFiles.indexOf(p))
                }))
            ))];
            updateUndoButton();
        }

        function undo() {
            if (_groupHistory.length === 0) return;
            const saved = _groupHistory.pop();
            groups = saved.map(s => ({
                ...s,
                photos: s.photoIndices.map(i => uploadedFiles[i]).filter(Boolean)
            }));
            renderGroupConfirm();
            showToast('ÂÖÉ„Å´Êàª„Åó„Åæ„Åó„Åü ‚úì');
            updateUndoButton();
        }

        function updateUndoButton() {
            const btn = document.getElementById('undoBtn');
            if (btn) btn.disabled = _groupHistory.length === 0;
        }

        function clearSelection() {
            _selectedPhotos.clear();
            document.querySelectorAll('.group-photo-thumb.selected').forEach(el => el.classList.remove('selected'));
            updateSelectionBar();
        }

        function updateSelectionBar() {
            let bar = document.getElementById('selectionBar');
            if (_selectedPhotos.size === 0) {
                if (bar) bar.remove();
                return;
            }
            if (!bar) {
                bar = document.createElement('div');
                bar.className = 'selection-bar';
                bar.id = 'selectionBar';
                const groupList = document.getElementById('groupList');
                groupList.parentElement.insertBefore(bar, groupList);
            }

            // Build destination group buttons
            const destButtons = groups.map((g, gi) => {
                const displayName = g.name && g.name !== g.label ? `${g.label}: ${g.name}` : g.label;
                return `<button class="dest-btn" style="background:${g.color}" onclick="moveSelectedToGroup(${gi})">${displayName}</button>`;
            }).join('');

            bar.innerHTML = `
                <span class="sel-label">üìå ${_selectedPhotos.size}Êûö„ÇíÈÅ∏Êäû‰∏≠</span>
                <span class="sel-arrow">‚Üí ÁßªÂãïÂÖà:</span>
                ${destButtons}
                <button onclick="clearSelection()">ÈÅ∏ÊäûËß£Èô§</button>
            `;
        }

        function moveSelectedToGroup(toGroupIdx) {
            saveState();
            moveSelectedPhotos(toGroupIdx);
        }

        function renderGroupConfirm() {
            const list = document.getElementById('groupList');
            list.innerHTML = '';
            _selectedPhotos.clear();
            const bar = document.getElementById('selectionBar');
            if (bar) bar.remove();

            const totalPhotos = groups.reduce((s, g) => s + g.photos.length, 0);
            const totalLimit = groups.reduce((s, g) => s + (parseInt(g.limit) || 0), 0);
            document.getElementById('sumPhotos').textContent = totalPhotos;
            document.getElementById('sumGroups').textContent = groups.length;
            document.getElementById('sumLimit').textContent = totalLimit;

            groups.forEach((g, gi) => {
                const card = document.createElement('div');
                card.className = 'group-card open';
                card.innerHTML = `
          <div class="group-card-header" onclick="toggleCard(${gi})">
            <div class="group-label-badge" style="background:${g.color}">${g.label}</div>
            <div class="group-name-wrap">
              <input class="group-name-input" id="gname-${gi}"
                value="${g.name}"
                placeholder="${g.label}"
                onclick="event.stopPropagation()"
                oninput="updateGroupName(${gi}, this.value)">
              <span style="cursor:pointer;opacity:0.4;font-size:13px;margin-left:4px;" title="„Ç∞„É´„Éº„ÉóÂêç„ÇíÁ∑®ÈõÜ" onclick="event.stopPropagation();document.getElementById('gname-${gi}').focus()">‚úèÔ∏è</span>
            </div>
            <div class="group-meta">
              <div class="group-photo-count">${g.photos.length}Êûö</div>
              <div class="group-limit-wrap">
                <span class="group-limit-label">‰∏äÈôê</span>
                <input class="group-limit-input" type="number" min="1" max="${g.photos.length}"
                  value="${g.limit}" id="glimit-${gi}"
                  onclick="event.stopPropagation()"
                  oninput="updateGroupLimit(${gi}, this.value)">
                <span class="group-limit-unit">Êûö</span>
              </div>
              ${groups.length > 1 ? `<button class="btn-delete-group" onclick="event.stopPropagation();deleteGroup(${gi})" title="„Ç∞„É´„Éº„ÉóÂâäÈô§">üóë</button>` : ''}
              <div class="group-toggle">‚ñæ</div>
            </div>
          </div>
          <div class="group-card-photos">
            <div class="group-photos-grid" id="gphoto-${gi}"
              data-group="${gi}"></div>
          </div>
        `;
                list.appendChild(card);

                // Setup drop target
                const grid = card.querySelector(`#gphoto-${gi}`);
                grid.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    grid.classList.add('drag-over');
                });
                grid.addEventListener('dragleave', () => {
                    grid.classList.remove('drag-over');
                });
                grid.addEventListener('drop', (e) => {
                    e.preventDefault();
                    grid.classList.remove('drag-over');
                    if (_dragData && _dragData.fromGroup !== gi) {
                        if (_selectedPhotos.size > 0 && _selectedPhotos.has(_selKey(_dragData.fromGroup, _dragData.photoIndex))) {
                            // Move all selected photos
                            moveSelectedPhotos(gi);
                        } else {
                            // Move single photo
                            movePhoto(_dragData.fromGroup, _dragData.photoIndex, gi);
                        }
                    }
                    _dragData = null;
                });

                // Render draggable thumbnails
                g.photos.forEach((p, pi) => {
                    const thumb = document.createElement('div');
                    thumb.className = 'group-photo-thumb';
                    thumb.draggable = true;
                    thumb.innerHTML = `<img src="${p.url}" alt="${p.file.name}" loading="lazy">`;

                    // Click to toggle selection (Shift = range select)
                    thumb.addEventListener('click', (e) => {
                        e.preventDefault();
                        const key = _selKey(gi, pi);

                        if (e.shiftKey && _lastClicked && _lastClicked.gi === gi) {
                            // Shift+click: select range within same group
                            const from = Math.min(_lastClicked.pi, pi);
                            const to = Math.max(_lastClicked.pi, pi);
                            const grid = document.getElementById(`gphoto-${gi}`);
                            const thumbs = grid.querySelectorAll('.group-photo-thumb');
                            for (let idx = from; idx <= to; idx++) {
                                _selectedPhotos.add(_selKey(gi, idx));
                                if (thumbs[idx]) thumbs[idx].classList.add('selected');
                            }
                        } else {
                            // Normal click: toggle single
                            if (_selectedPhotos.has(key)) {
                                _selectedPhotos.delete(key);
                                thumb.classList.remove('selected');
                            } else {
                                _selectedPhotos.add(key);
                                thumb.classList.add('selected');
                            }
                        }
                        _lastClicked = { gi, pi };
                        updateSelectionBar();
                    });

                    thumb.addEventListener('dragstart', (e) => {
                        _dragData = { fromGroup: gi, photoIndex: pi };
                        thumb.classList.add('dragging');
                        e.dataTransfer.effectAllowed = 'move';
                        // If dragging a selected photo, show count
                        if (_selectedPhotos.size > 0 && _selectedPhotos.has(_selKey(gi, pi))) {
                            e.dataTransfer.setData('text/plain', `${_selectedPhotos.size}ÊûöÁßªÂãï`);
                        }
                    });
                    thumb.addEventListener('dragend', () => {
                        thumb.classList.remove('dragging');
                        document.querySelectorAll('.drag-over').forEach(el => el.classList.remove('drag-over'));
                    });

                    grid.appendChild(thumb);
                });
            });
        }

        function movePhoto(fromGroupIdx, photoIdx, toGroupIdx) {
            if (fromGroupIdx === toGroupIdx) return;
            saveState();
            const photo = groups[fromGroupIdx].photos.splice(photoIdx, 1)[0];
            groups[toGroupIdx].photos.push(photo);
            if (groups[fromGroupIdx].photos.length === 0) {
                groups.splice(fromGroupIdx, 1);
                reassignLabels();
            }
            renderGroupConfirm();
            showToast('ÂÜôÁúü„ÇíÁßªÂãï„Åó„Åæ„Åó„Åü ‚úì');
        }

        function moveSelectedPhotos(toGroupIdx) {
            // Collect selected photos grouped by source group (reverse order to avoid index shift)
            const byGroup = {};
            _selectedPhotos.forEach(key => {
                const [gi, pi] = key.split('-').map(Number);
                if (gi === toGroupIdx) return; // Skip if same group
                if (!byGroup[gi]) byGroup[gi] = [];
                byGroup[gi].push(pi);
            });

            let movedCount = 0;
            // Process groups in reverse to avoid index shifting
            const groupIndices = Object.keys(byGroup).map(Number).sort((a, b) => b - a);
            for (const gi of groupIndices) {
                // Sort photo indices in reverse
                const indices = byGroup[gi].sort((a, b) => b - a);
                for (const pi of indices) {
                    const photo = groups[gi].photos.splice(pi, 1)[0];
                    groups[toGroupIdx].photos.push(photo);
                    movedCount++;
                }
            }

            // Remove empty groups (reverse order)
            for (let i = groups.length - 1; i >= 0; i--) {
                if (groups[i].photos.length === 0) {
                    groups.splice(i, 1);
                }
            }
            reassignLabels();
            renderGroupConfirm();
            showToast(`${movedCount}Êûö„ÇíÁßªÂãï„Åó„Åæ„Åó„Åü ‚úì`);
        }

        function addNewGroup() {
            saveState();
            const idx = groups.length;
            const label = LABELS[idx] || String(idx + 1);
            groups.push({
                label: label,
                name: label,
                reason: '',
                color: GROUP_COLORS[idx % GROUP_COLORS.length],
                limit: 1,
                photos: []
            });
            renderGroupConfirm();
            showToast('„Ç∞„É´„Éº„Éó„ÇíËøΩÂä†„Åó„Åæ„Åó„Åü');
        }

        function deleteGroup(gi) {
            if (groups.length <= 1) return;
            saveState();
            const removedPhotos = groups[gi].photos;
            groups.splice(gi, 1);
            // Distribute orphan photos to the first remaining group
            if (removedPhotos.length > 0) {
                groups[0].photos.push(...removedPhotos);
            }
            reassignLabels();
            renderGroupConfirm();
            showToast('„Ç∞„É´„Éº„Éó„ÇíÂâäÈô§„Åó„Åæ„Åó„Åü');
        }

        function reassignLabels() {
            groups.forEach((g, i) => {
                g.label = LABELS[i] || String(i + 1);
                g.color = GROUP_COLORS[i % GROUP_COLORS.length];
            });
        }

        function toggleCard(gi) {
            const cards = document.querySelectorAll('.group-card');
            cards[gi].classList.toggle('open');
        }

        function updateGroupName(gi, val) {
            groups[gi].name = val;
        }

        function updateGroupLimit(gi, val) {
            groups[gi].limit = parseInt(val) || 1;
            updateSummary();
        }

        function updateSummary() {
            const totalLimit = groups.reduce((s, g) => s + (parseInt(g.limit) || 0), 0);
            document.getElementById('sumLimit').textContent = totalLimit;
        }


        // Share functions (consolidated ‚Äî cloud upload handles everything)
        // openShare / closeShare / copyLink removed ‚Äî now handled by previewSelect()

        // =====================================================================
        // AI DETECTION UTILITIES
        // =====================================================================

        /** Load a URL into an HTMLImageElement with timeout */
        function loadImg(url) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.crossOrigin = 'anonymous';
                const timer = setTimeout(() => {
                    img.src = ''; // stop loading
                    reject(new Error('Image load timeout'));
                }, 5000); // 5s timeout
                img.onload = () => { clearTimeout(timer); resolve(img); };
                img.onerror = (e) => { clearTimeout(timer); reject(e); };
                img.src = url;
            });
        }

        function createResizedCanvas(img) {
            const MAX_W = 800;
            let w = img.width;
            let h = img.height;
            if (w > MAX_W) {
                h = Math.round(h * (MAX_W / w));
                w = MAX_W;
            }
            const canvas = document.createElement('canvas');
            canvas.width = w;
            canvas.height = h;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0, w, h);
            return canvas;
        }

        /**
         * BLUR DETECTION ‚Äî Laplacian variance via Canvas API
         * Lower score = more blurry. Threshold: < 80 ‚Üí „Éî„É≥„Éú„Ç±
         */
        function detectBlur(img) {
            const SIZE = 256; // downsample for speed
            const canvas = document.createElement('canvas');
            canvas.width = SIZE; canvas.height = SIZE;
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            ctx.drawImage(img, 0, 0, SIZE, SIZE);
            const { data } = ctx.getImageData(0, 0, SIZE, SIZE);

            // Convert to grayscale
            const gray = new Float32Array(SIZE * SIZE);
            for (let i = 0; i < SIZE * SIZE; i++) {
                const o = i * 4;
                gray[i] = 0.299 * data[o] + 0.587 * data[o + 1] + 0.114 * data[o + 2];
            }

            // Laplacian kernel: [0,1,0, 1,-4,1, 0,1,0]
            let sum = 0, sum2 = 0, n = 0;
            for (let y = 1; y < SIZE - 1; y++) {
                for (let x = 1; x < SIZE - 1; x++) {
                    const idx = y * SIZE + x;
                    const lap = gray[idx - SIZE] + gray[idx + SIZE] +
                        gray[idx - 1] + gray[idx + 1] - 4 * gray[idx];
                    sum += lap; sum2 += lap * lap; n++;
                }
            }
            const mean = sum / n;
            const variance = sum2 / n - mean * mean;
            return variance; // higher = sharper
        }

        /**
         * EYE CLOSED DETECTION ‚Äî EAR (Eye Aspect Ratio) via face-api.js
         * EAR < 0.22 ‚Üí ÁõÆÈñâ„ÅòÔºàÂçäÁõÆÔºâ
         * Returns true if eye closed detected.
         */
        let _faceApiReady = false;
        let _faceApiLoading = false;
        let _faceApiAttempts = 0;

        async function _tryLoadFaceApi() {
            if (typeof faceapi === 'undefined') {
                console.warn('[FaceAPI] faceapi not loaded ‚Äî CDN script may have failed');
                return false;
            }
            const MODEL_URL = 'https://cdn.jsdelivr.net/npm/@vladmandic/face-api/model';

            // Load models with 15s timeout
            await Promise.race([
                Promise.all([
                    faceapi.nets.tinyFaceDetector.loadFromUri(MODEL_URL),
                    faceapi.nets.faceLandmark68TinyNet.loadFromUri(MODEL_URL),
                ]),
                new Promise((_, rej) => setTimeout(() => rej(new Error('Model load timeout (15s)')), 15000))
            ]);
            console.log('[FaceAPI] Models loaded successfully');

            // Warmup with 64x64 canvas (1x1 causes WebGL issues in some browsers)
            const dummy = document.createElement('canvas');
            dummy.width = 64; dummy.height = 64;
            const ctx = dummy.getContext('2d');
            ctx.fillStyle = '#888'; ctx.fillRect(0, 0, 64, 64);
            const opts = new faceapi.TinyFaceDetectorOptions({ inputSize: 224, scoreThreshold: 0.3 });

            await Promise.race([
                faceapi.detectSingleFace(dummy, opts).withFaceLandmarks(true),
                new Promise((_, rej) => setTimeout(() => rej(new Error('Warmup timeout (10s)')), 10000))
            ]);
            console.log('[FaceAPI] Warmup completed');
            return true;
        }

        async function ensureFaceApi() {
            if (_faceApiReady) return true;
            if (_faceApiLoading) {
                let waited = 0;
                while (_faceApiLoading && waited < 20000) {
                    await new Promise(r => setTimeout(r, 200));
                    waited += 200;
                }
                return _faceApiReady;
            }
            _faceApiLoading = true;

            // Try up to 2 times
            for (let attempt = 1; attempt <= 2; attempt++) {
                _faceApiAttempts = attempt;
                try {
                    console.log(`[FaceAPI] Initialization attempt ${attempt}...`);
                    const ok = await _tryLoadFaceApi();
                    if (ok) {
                        _faceApiReady = true;
                        _faceApiLoading = false;
                        console.log('[FaceAPI] ‚úì Ready');
                        return true;
                    }
                } catch (e) {
                    console.warn(`[FaceAPI] Attempt ${attempt} failed:`, e.message);
                    if (attempt < 2) {
                        console.log('[FaceAPI] Retrying in 2s...');
                        await new Promise(r => setTimeout(r, 2000));
                    }
                }
            }

            console.warn('[FaceAPI] ‚úó All attempts failed ‚Äî AI features disabled');
            _faceApiLoading = false;
            return false;
        }

        // Background preload: start loading FaceAPI 2s after page load
        setTimeout(() => {
            if (!_faceApiReady && !_faceApiLoading) {
                console.log('[FaceAPI] Starting background preload...');
                ensureFaceApi().then(ok => {
                    if (ok) console.log('[FaceAPI] Background preload succeeded');
                });
            }
        }, 2000);

        function _ear(landmarks, leftIdxs, rightIdxs) {
            // EAR = (||p2-p6|| + ||p3-p5||) / (2 * ||p1-p4||)
            const pts = landmarks.positions;
            function dist(a, b) {
                const dx = pts[a].x - pts[b].x, dy = pts[a].y - pts[b].y;
                return Math.sqrt(dx * dx + dy * dy);
            }
            const [p1, p2, p3, p4, p5, p6] = leftIdxs;
            const earL = (dist(p2, p6) + dist(p3, p5)) / (2 * dist(p1, p4));
            const [q1, q2, q3, q4, q5, q6] = rightIdxs;
            const earR = (dist(q2, q6) + dist(q3, q5)) / (2 * dist(q1, q4));
            return (earL + earR) / 2;
        }

        async function detectEyeClosed(img) {
            const ready = await ensureFaceApi();
            if (!ready) return false;
            try {
                // Optimized input size for speed (default 416 -> 320)
                const opts = new faceapi.TinyFaceDetectorOptions({ inputSize: 320, scoreThreshold: 0.4 });
                const result = await faceapi
                    .detectSingleFace(img, opts)
                    .withFaceLandmarks(true); // true = tiny model
                if (!result) return false;
                // 68-point landmark indices for eyes
                // Left eye: 36-41, Right eye: 42-47
                const ear = _ear(result.landmarks,
                    [36, 37, 38, 39, 40, 41],
                    [42, 43, 44, 45, 46, 47]);
                return ear < 0.22;
            } catch (e) {
                console.warn('detectEyeClosed error:', e);
                return false;
            }
        }

        /**
         * SIMILARITY DETECTION ‚Äî dHash (difference hash)
         * Returns a 64-bit hash as Uint8Array(64)
         */
        function computeDHash(img) {
            const W = 9, H = 8; // 9 columns, 8 rows ‚Üí 64-bit hash
            const canvas = document.createElement('canvas');
            canvas.width = W; canvas.height = H;
            const ctx = canvas.getContext('2d', { willReadFrequently: true });
            ctx.drawImage(img, 0, 0, W, H);
            const { data } = ctx.getImageData(0, 0, W, H);
            const hash = new Uint8Array(H * (W - 1)); // 64 bits
            let bit = 0;
            for (let y = 0; y < H; y++) {
                for (let x = 0; x < W - 1; x++) {
                    const idx = (y * W + x) * 4;
                    const left = 0.299 * data[idx] + 0.587 * data[idx + 1] + 0.114 * data[idx + 2];
                    const right = 0.299 * data[idx + 4] + 0.587 * data[idx + 5] + 0.114 * data[idx + 6];
                    hash[bit++] = left > right ? 1 : 0;
                }
            }
            return hash;
        }

        function hammingDistance(a, b) {
            let dist = 0;
            for (let i = 0; i < a.length; i++) dist += a[i] !== b[i] ? 1 : 0;
            return dist;
        }

        // =====================================================================
        // AI ORCHESTRATOR
        // =====================================================================

        /**
         * Run all AI analyses on a flat list of photo objects.
         */
        async function runAIAnalysis(allPhotos, onProgress) {
            const BLUR_THRESHOLD = 80;
            const SIMILAR_THRESHOLD = 10;

            // 1. Warmup FaceAPI with UI feedback
            // This might freeze the UI for a few seconds only ONCE
            if (onProgress) onProgress('AI„Ç®„É≥„Ç∏„É≥Ëµ∑Âãï‰∏≠...', 0);
            await new Promise(r => setTimeout(r, 100)); // Allow UI to render
            await ensureFaceApi();

            // Compute hashes for all photos first (fast)
            const hashes = [];
            for (let i = 0; i < allPhotos.length; i++) {
                try {
                    const resized = createResizedCanvas(allPhotos[i].img);
                    hashes.push(computeDHash(resized));
                } catch (e) {
                    hashes.push(new Uint8Array(64)); // dummy
                    console.warn(`Hash failed for ${i}`, e);
                }
            }

            // Detect similarity
            const similar = new Set();
            for (let i = 0; i < allPhotos.length; i++) {
                for (let j = i + 1; j < allPhotos.length; j++) {
                    if (hammingDistance(hashes[i], hashes[j]) <= SIMILAR_THRESHOLD) {
                        similar.add(i);
                        similar.add(j);
                    }
                }
            }

            // Per-photo analysis: SEQUENTIAL + TIMEOUT
            // Processing one by one to ensure stability and prevent freezing
            for (let i = 0; i < allPhotos.length; i++) {
                const p = allPhotos[i];
                const globalIdx = i;

                // Update text BEFORE processing
                onProgress(i + 1, allPhotos.length);

                // Allow UI to render
                await new Promise(r => setTimeout(r, 10));

                try {
                    // Wrap analysis in a Promise.race with timeout
                    await Promise.race([
                        (async () => {
                            const resized = createResizedCanvas(p.img);

                            // Blur
                            const blurScore = detectBlur(resized);
                            if (blurScore < BLUR_THRESHOLD) p.aiTags.add('„Éî„É≥„Éú„Ç±');

                            // Eye closed (most likely to hang)
                            const eyeClosed = await detectEyeClosed(resized);
                            if (eyeClosed) p.aiTags.add('ÂçäÁõÆ');

                            // Similarity
                            if (similar.has(globalIdx)) p.aiTags.add('È°û‰ºº');
                        })(),
                        new Promise((_, reject) => setTimeout(() => reject(new Error('AI timeout')), 4000))
                    ]);
                } catch (e) {
                    console.warn(`Skipping photo ${globalIdx} due to error/timeout:`, e);
                }
            }
        }

        // =====================================================================
        // PREVIEW SELECT (now async with AI analysis)
        // =====================================================================

        async function previewSelect() {
            const btn = document.getElementById('previewBtn');

            const totalPhotos = groups.reduce((s, g) => s + g.photos.length, 0);
            if (totalPhotos === 0) {
                showToast('ÂÜôÁúü„Åå„ÅÇ„Çä„Åæ„Åõ„Çì');
                return;
            }

            if (btn) {
                btn.disabled = true;
                btn.textContent = '„Çµ„É†„Éç„Ç§„É´ÁîüÊàê‰∏≠‚Ä¶';
            }

            try {
                await _doPreviewSelect(null);
            } catch (err) {
                console.error('Preview error:', err);
                showToast('„Ç®„É©„Éº„ÅåÁô∫Áîü„Åó„Åæ„Åó„Åü: ' + err.message);
            } finally {
                if (btn) {
                    btn.disabled = false;
                    btn.textContent = '„Éó„É¨„Éì„É•„Éº & „Çª„É¨„ÇØ„Éà ‚Üí';
                }
            }
        }

        // Convert File object or blob URL to data URL thumbnail via canvas
        // Uses File directly (more reliable than blob URLs which can be revoked)
        function fileToDataUrl(fileOrBlobUrl, maxSize) {
            return new Promise((resolve) => {
                // 5 second timeout to prevent hanging
                const timeout = setTimeout(() => {
                    console.warn('[Thumb] Timeout for:', typeof fileOrBlobUrl === 'string' ? fileOrBlobUrl : fileOrBlobUrl?.name);
                    resolve('');
                }, 5000);

                const img = new Image();
                img.onload = function () {
                    clearTimeout(timeout);
                    try {
                        const canvas = document.createElement('canvas');
                        let w = img.naturalWidth, h = img.naturalHeight;
                        if (w > maxSize || h > maxSize) {
                            if (w > h) { h = Math.round(h * maxSize / w); w = maxSize; }
                            else { w = Math.round(w * maxSize / h); h = maxSize; }
                        }
                        canvas.width = w;
                        canvas.height = h;
                        canvas.getContext('2d').drawImage(img, 0, 0, w, h);
                        const result = canvas.toDataURL('image/jpeg', 0.85);
                        URL.revokeObjectURL(img.src); // Clean up if we created a URL
                        resolve(result);
                    } catch (e) {
                        console.warn('[Thumb] Canvas error:', e);
                        resolve('');
                    }
                };
                img.onerror = () => {
                    clearTimeout(timeout);
                    console.warn('[Thumb] Image load error');
                    resolve('');
                };

                // Prefer File object over blob URL (blob URLs can expire)
                if (fileOrBlobUrl instanceof File || fileOrBlobUrl instanceof Blob) {
                    img.src = URL.createObjectURL(fileOrBlobUrl);
                } else if (typeof fileOrBlobUrl === 'string' && fileOrBlobUrl) {
                    img.src = fileOrBlobUrl;
                } else {
                    clearTimeout(timeout);
                    resolve('');
                }
            });
        }

        async function _doPreviewSelect(targetWindow) {
            const btn = document.getElementById('previewBtn');
            if (btn) btn.textContent = '„Çµ„É†„Éç„Ç§„É´ÁîüÊàê‰∏≠‚Ä¶';

            const totalPhotos = groups.reduce((s, g) => s + g.photos.length, 0);
            console.log('[Preview] Starting thumbnail generation for', totalPhotos, 'photos');

            // Build data with data URL thumbnails
            const data = [];
            let processed = 0;
            for (let i = 0; i < groups.length; i++) {
                const g = groups[i];
                const photos = [];
                for (let j = 0; j < g.photos.length; j++) {
                    processed++;
                    if (btn) btn.textContent = `„Çµ„É†„Éç„Ç§„É´ÁîüÊàê‰∏≠‚Ä¶ ${processed}/${totalPhotos}`;

                    const p = g.photos[j];
                    let dataUrl = '';
                    try {
                        // Use File object directly (more reliable than blob URL)
                        dataUrl = await fileToDataUrl(p.file || p.url, 1200);
                    } catch (e) {
                        console.warn(`[Preview] Thumb failed for ${p.file?.name || 'unknown'}:`, e);
                    }

                    photos.push({
                        id: `${g.label.toLowerCase()}${j + 1}`,
                        fname: p.file ? p.file.name : `photo_${j + 1}.jpg`,
                        url: dataUrl,
                        ai: p._aiTags || []
                    });
                }
                data.push({
                    id: `g${i + 1}`,
                    label: g.label,
                    name: g.name || g.label,
                    color: g.color,
                    limit: parseInt(g.limit) || 1,
                    photos: photos
                });
            }

            console.log('[Preview] Thumbnails done:', processed, 'photos');

            if (btn) btn.textContent = 'ÁîªÈù¢ÈÅ∑Áßª‰∏≠‚Ä¶';

            // Save to localStorage (works on file:// unlike sessionStorage)
            try {
                localStorage.setItem('selekt_groups', JSON.stringify(data));
                console.log('Saved data to localStorage:', data.length, 'groups,',
                    data.reduce((a, g) => a + g.photos.length, 0), 'photos');
            } catch (e) {
                console.warn('localStorage save failed (data too large?):', e);
                try {
                    const lite = data.map(g => ({ ...g, photos: g.photos.map(p => ({ ...p, url: '' })) }));
                    localStorage.setItem('selekt_groups', JSON.stringify(lite));
                    console.log('Saved lite data (no thumbnails) to localStorage');
                } catch (e2) {
                    console.error('Even lite save failed:', e2);
                }
            }

            // === CLOUD UPLOAD (SELEKT API) ===
            const API_BASE = 'https://selekt-api.mr-mail114.workers.dev';
            let sessionId = null;

            try {
                if (btn) btn.textContent = '„ÇØ„É©„Ç¶„Éâ„Å´„Çª„ÉÉ„Ç∑„Éß„É≥‰ΩúÊàê‰∏≠‚Ä¶';

                // Create session
                const sessionRes = await fetch(`${API_BASE}/api/session`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        title: document.getElementById('sessionTitle')?.value || '',
                        photographer: document.getElementById('photographerName')?.value || '',
                        groups: data.map(g => ({
                            id: g.id, label: g.label, name: g.name,
                            color: g.color, limit: g.limit,
                            photoCount: g.photos.length
                        }))
                    })
                });
                const sessionData = await sessionRes.json();
                sessionId = sessionData.sessionId;
                console.log('[SELEKT] Session created:', sessionId);

                // Upload photos
                const totalPhotos = groups.reduce((a, g) => a + g.photos.length, 0);
                let uploaded = 0;

                for (let i = 0; i < groups.length; i++) {
                    const g = groups[i];
                    for (let j = 0; j < g.photos.length; j++) {
                        uploaded++;
                        if (btn) btn.textContent = `„ÇØ„É©„Ç¶„Éâ„Å´„Ç¢„ÉÉ„Éó„É≠„Éº„Éâ‰∏≠‚Ä¶ ${uploaded}/${totalPhotos}`;

                        const p = g.photos[j];
                        const photoData = data[i].photos[j];
                        const formData = new FormData();
                        formData.append('file', p.file);
                        formData.append('fname', p.file.name);
                        formData.append('groupId', data[i].id);

                        // Add thumbnail as blob
                        if (photoData.url && photoData.url.startsWith('data:')) {
                            const thumbRes = await fetch(photoData.url);
                            const thumbBlob = await thumbRes.blob();
                            formData.append('thumb', thumbBlob, p.file.name);
                        }

                        await fetch(`${API_BASE}/api/session/${sessionId}/upload`, {
                            method: 'POST',
                            body: formData
                        });
                    }
                }

                console.log('[SELEKT] All photos uploaded to cloud');

                // Save session ID
                localStorage.setItem('selekt_sessionId', sessionId);

                if (btn) btn.textContent = '„Ç¢„ÉÉ„Éó„É≠„Éº„ÉâÂÆå‰∫ÜÔºÅ';

            } catch (cloudErr) {
                console.warn('[SELEKT] Cloud upload failed, using local mode:', cloudErr);
                showToast('„ÇØ„É©„Ç¶„Éâ„Ç¢„ÉÉ„Éó„É≠„Éº„ÉâÂ§±Êïó„ÄÇ„É≠„Éº„Ç´„É´„É¢„Éº„Éâ„ÅßÁ∂öË°å„Åó„Åæ„Åô');
            }

            // Build the select URL
            const selectUrl = sessionId
                ? `SELEKT_Select.html?session=${sessionId}`
                : 'SELEKT_Select.html?from=upload';
            // Always use GitHub Pages URL for sharing (not file:// or localhost)
            const SHARE_BASE = 'https://mr114777.github.io/piccheck/';
            const fullShareUrl = sessionId ? `${SHARE_BASE}${selectUrl}` : null;

            // Show share dialog if cloud upload succeeded
            if (sessionId && fullShareUrl) {
                const overlay = document.createElement('div');
                overlay.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.7);display:flex;align-items:center;justify-content:center;z-index:9999;';
                overlay.innerHTML = `
                    <div style="background:var(--surface);border:1px solid var(--border2);border-radius:16px;padding:32px;max-width:500px;width:90%;text-align:center;">
                        <div style="font-size:32px;margin-bottom:12px;">‚úÖ</div>
                        <div style="font-size:18px;font-weight:700;margin-bottom:8px;">„ÇØ„É©„Ç¶„Éâ„Ç¢„ÉÉ„Éó„É≠„Éº„ÉâÂÆå‰∫ÜÔºÅ</div>
                        <div style="font-size:13px;color:var(--text-sub);margin-bottom:20px;">
                            ‰ª•‰∏ã„ÅÆURL„ÇíÂÖ±Êúâ„Åô„Çã„Å®„ÄÅ‰ªñ„ÅÆ‰∫∫„ÇÇÂÜôÁúü„ÇíÈñ≤Ë¶ß„Åß„Åç„Åæ„Åô
                        </div>
                        <div style="background:var(--bg);border:1px solid var(--border);border-radius:10px;padding:12px;margin-bottom:16px;word-break:break-all;font-family:'Space Mono',monospace;font-size:12px;color:var(--text);text-align:left;" id="shareUrlText">
                            ${fullShareUrl}
                        </div>
                        <div style="display:flex;gap:10px;justify-content:center;">
                            <button id="copyShareBtn"
                                style="padding:12px 24px;background:var(--coral);color:white;border:none;border-radius:10px;font-size:14px;font-weight:700;cursor:pointer;font-family:inherit;">
                                üìã URL„Çí„Ç≥„Éî„Éº
                            </button>
                            <button id="goSelectBtn"
                                style="padding:12px 24px;background:var(--surface2);color:var(--text);border:1px solid var(--border);border-radius:10px;font-size:14px;font-weight:600;cursor:pointer;font-family:inherit;">
                                „Çª„É¨„ÇØ„ÉàÁîªÈù¢„Å∏ ‚Üí
                            </button>
                        </div>
                    </div>
                `;
                document.body.appendChild(overlay);

                // Attach event listeners (proper JS, not inline onclick)
                document.getElementById('copyShareBtn').addEventListener('click', function () {
                    navigator.clipboard.writeText(fullShareUrl).then(() => {
                        this.textContent = '‚úì „Ç≥„Éî„ÉºÊ∏à„Åø';
                        this.style.background = 'var(--green)';
                    }).catch(() => {
                        // Fallback: select text
                        const range = document.createRange();
                        range.selectNodeContents(document.getElementById('shareUrlText'));
                        window.getSelection().removeAllRanges();
                        window.getSelection().addRange(range);
                        this.textContent = 'ÈÅ∏ÊäûÊ∏à„ÅøÔºàCtrl+C„Åß„Ç≥„Éî„ÉºÔºâ';
                    });
                });
                document.getElementById('goSelectBtn').addEventListener('click', function () {
                    overlay.remove();
                    window.open(fullShareUrl, '_blank');
                });
            } else {
                // No cloud session, navigate directly
                if (targetWindow && !targetWindow.closed) {
                    targetWindow.location.href = selectUrl;
                } else {
                    window.open(selectUrl, '_blank');
                }
            }
        }

        // ===== TOAST =====
        let toastTimer;
        function showToast(msg) {
            const t = document.getElementById('toast');
            t.textContent = msg;
            t.classList.add('show');
            clearTimeout(toastTimer);
            toastTimer = setTimeout(() => t.classList.remove('show'), 2200);
        }
    </script>
</body>

</html>